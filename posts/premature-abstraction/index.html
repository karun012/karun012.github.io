<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Premature abstraction | Karun Ramakrishnan</title>
<meta name=keywords content="programming,design"><meta name=description content="
TL;DR - Stick to something like the rule of three. Premature abstraction in any system is almost always going to be problematic, expensive and frustrating. Never add abstractions because you &ldquo;might&rdquo; need it in the future. Add it when you &ldquo;really&rdquo; need it
Abstraction is a good way of hiding complexity. In your software development life, you probably have created well rounded abstractions that made your life easier. While abstractions make things cleaner and easier to work with, premature abstraction will have the opposite effect."><meta name=author content="Karun Ramakrishnan"><link rel=canonical href=https://www.karun.dev/posts/premature-abstraction/><link crossorigin=anonymous href=https://www.karun.dev/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://www.karun.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.karun.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.karun.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://www.karun.dev/apple-touch-icon.png><link rel=mask-icon href=https://www.karun.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.karun.dev/posts/premature-abstraction/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://www.karun.dev/posts/premature-abstraction/"><meta property="og:site_name" content="Karun Ramakrishnan"><meta property="og:title" content="Premature abstraction"><meta property="og:description" content=" TL;DR - Stick to something like the rule of three. Premature abstraction in any system is almost always going to be problematic, expensive and frustrating. Never add abstractions because you “might” need it in the future. Add it when you “really” need it
Abstraction is a good way of hiding complexity. In your software development life, you probably have created well rounded abstractions that made your life easier. While abstractions make things cleaner and easier to work with, premature abstraction will have the opposite effect."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-23T21:00:00-07:00"><meta property="article:modified_time" content="2020-07-23T21:00:00-07:00"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Design"><meta name=twitter:card content="summary"><meta name=twitter:title content="Premature abstraction"><meta name=twitter:description content="
TL;DR - Stick to something like the rule of three. Premature abstraction in any system is almost always going to be problematic, expensive and frustrating. Never add abstractions because you &ldquo;might&rdquo; need it in the future. Add it when you &ldquo;really&rdquo; need it
Abstraction is a good way of hiding complexity. In your software development life, you probably have created well rounded abstractions that made your life easier. While abstractions make things cleaner and easier to work with, premature abstraction will have the opposite effect."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.karun.dev/posts/"},{"@type":"ListItem","position":2,"name":"Premature abstraction","item":"https://www.karun.dev/posts/premature-abstraction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Premature abstraction","name":"Premature abstraction","description":" TL;DR - Stick to something like the rule of three. Premature abstraction in any system is almost always going to be problematic, expensive and frustrating. Never add abstractions because you \u0026ldquo;might\u0026rdquo; need it in the future. Add it when you \u0026ldquo;really\u0026rdquo; need it\nAbstraction is a good way of hiding complexity. In your software development life, you probably have created well rounded abstractions that made your life easier. While abstractions make things cleaner and easier to work with, premature abstraction will have the opposite effect.\n","keywords":["programming","design"],"articleBody":" TL;DR - Stick to something like the rule of three. Premature abstraction in any system is almost always going to be problematic, expensive and frustrating. Never add abstractions because you “might” need it in the future. Add it when you “really” need it\nAbstraction is a good way of hiding complexity. In your software development life, you probably have created well rounded abstractions that made your life easier. While abstractions make things cleaner and easier to work with, premature abstraction will have the opposite effect.\nImagine working on a new feature. You start building parts of it either top down or bottom up (I tend to prefer top down over bottom up). Almost immediately you start seeing little patterns of duplicated code. Voila! You make an abstraction and it is beautiful. Life continues, you get your tasty lunch, get that coffee and go back to writing more code.\nYou start adding more features. To work with the growing complexity you try to make your abstraction more accommodating. Before you know it the abstraction that started to look like a TV remote has now become a microwave oven that can also tell you a joke, and has sprouted horns. The problem is not that creating that abstraction is bad. It is just the timing of it all. The abstraction got created too soon. All the duplicated code that seemed messy and hard to maintain is just in a different place. It is probably even harder to maintain this code now.\nThe maintainable way of creating abstractions is to fully understand your problem domain first. If you feel you will need this abstraction right at the start, stop and think about it for a little bit. There could very well be just one instance of this and you may not need it at all. The next instance might be entirely different. If you wait until you see more need for the abstraction, it is not anymore complex or expensive to introduce it at a later time. On the other hand, if you introduce it now and want to get out of it after you’ve made it incredibly complex, it will be expensive and frustrating.\nThe rule of three as popularised by Martin Fowler is probably a good rule to follow ¯\\_(ツ)_/¯. I personally try to follow it.\n","wordCount":"385","inLanguage":"en","datePublished":"2020-07-23T21:00:00-07:00","dateModified":"2020-07-23T21:00:00-07:00","author":{"@type":"Person","name":"Karun Ramakrishnan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.karun.dev/posts/premature-abstraction/"},"publisher":{"@type":"Organization","name":"Karun Ramakrishnan","logo":{"@type":"ImageObject","url":"https://www.karun.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.karun.dev/ accesskey=h title="Karun Ramakrishnan (Alt + H)">Karun Ramakrishnan</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.karun.dev/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://www.karun.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.karun.dev/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.karun.dev/>Home</a>&nbsp;»&nbsp;<a href=https://www.karun.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Premature abstraction</h1><div class=post-meta><span title='2020-07-23 21:00:00 -0700 -0700'>July 23, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;385 words&nbsp;·&nbsp;Karun Ramakrishnan</div></header><div class=post-content><blockquote><p><strong>TL;DR</strong> - Stick to something like the rule of three. Premature abstraction in any system is almost always going to be problematic, expensive and frustrating. Never add abstractions because you &ldquo;might&rdquo; need it in the future. Add it when you &ldquo;really&rdquo; need it</p></blockquote><p>Abstraction is a good way of hiding complexity. In your software development life, you probably have created well rounded abstractions that made your life easier. While abstractions make things cleaner and easier to work with, premature abstraction will have the opposite effect.</p><p>Imagine working on a new feature. You start building parts of it either top down or bottom up (I tend to prefer top down over bottom up). Almost immediately you start seeing little patterns of duplicated code. Voila! You make an abstraction and it is beautiful. Life continues, you get your tasty lunch, get that coffee and go back to writing more code.</p><p>You start adding more features. To work with the growing complexity you try to make your abstraction more accommodating. Before you know it the abstraction that started to look like a TV remote has now become a microwave oven that can also tell you a joke, and has sprouted horns. The problem is not that creating that abstraction is bad. It is just the timing of it all. The abstraction got created too soon. All the duplicated code that seemed messy and hard to maintain is just in a different place. It is probably even harder to maintain this code now.</p><p>The maintainable way of creating abstractions is to fully understand your problem domain first. If you feel you will need this abstraction right at the start, stop and think about it for a little bit. There could very well be just one instance of this and you may not need it at all. The next instance might be entirely different. If you wait until you see more need for the abstraction, it is not anymore complex or expensive to introduce it at a later time. On the other hand, if you introduce it now and want to get out of it after you&rsquo;ve made it incredibly complex, it will be expensive and frustrating.</p><p>The rule of three as popularised by Martin Fowler is probably a good rule to follow ¯\_(ツ)_/¯. I personally try to follow it.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.karun.dev/tags/programming/>Programming</a></li><li><a href=https://www.karun.dev/tags/design/>Design</a></li></ul><nav class=paginav><a class=prev href=https://www.karun.dev/posts/nine-and-a-half-commandments/><span class=title>« Prev</span><br><span>My nine and a half commandments</span>
</a><a class=next href=https://www.karun.dev/posts/test-the-test/><span class=title>Next »</span><br><span>Lessons from TDD - Logic in unit tests</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.karun.dev/>Karun Ramakrishnan</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>